"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5516],{3023:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>o});var s=i(3696);const t={},l=s.createContext(t);function r(e){const n=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(l.Provider,{value:n},e.children)}},3733:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"Nomenclature/Nomenclature","title":"Nomenclature","description":"In sphereneRHINO, several unique terms and components are used to define and control the geometry. Understanding these terms is crucial for effectively utilizing the tool. Below is an introduction to these components:","source":"@site/../obsidian-spherene-documentation/Nomenclature/Nomenclature.md","sourceDirName":"Nomenclature","slug":"/Nomenclature/","permalink":"/sphereneRHINO/Nomenclature/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":50,"frontMatter":{"sidebar_position":50},"sidebar":"tutorialSidebar","previous":{"title":"Known Issues and Troubleshooting","permalink":"/sphereneRHINO/knownissues"}}');var t=i(2540),l=i(3023);const r={sidebar_position:50},o="Nomenclature",a={},d=[{value:"ADMS (Adaptive Density Minimal Surface)",id:"adms-adaptive-density-minimal-surface",level:2},{value:"spherene / spherenes",id:"spherene--spherenes",level:2},{value:"Envelope (env)",id:"envelope-env",level:2},{value:"Defeatured Envelope (dfenv)",id:"defeatured-envelope-dfenv",level:2},{value:"Boundary (boundary)",id:"boundary-boundary",level:2},{value:"Field Points",id:"field-points",level:2},{value:"Density Field Points",id:"density-field-points",level:3},{value:"Thickness Field Points",id:"thickness-field-points",level:3},{value:"Surface Bias Field Points",id:"surface-bias-field-points",level:3},{value:"Cavity Points",id:"cavity-points",level:3},{value:"Density Reference Thickness (DRT)",id:"density-reference-thickness-drt",level:2},{value:"Computing spherene",id:"computing-spherene",level:2},{value:"Single Surface",id:"single-surface",level:3},{value:"Solid Surface",id:"solid-surface",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"nomenclature",children:"Nomenclature"})}),"\n",(0,t.jsx)(n.p,{children:"In sphereneRHINO, several unique terms and components are used to define and control the geometry. Understanding these terms is crucial for effectively utilizing the tool. Below is an introduction to these components:"}),"\n",(0,t.jsx)(n.h2,{id:"adms-adaptive-density-minimal-surface",children:"ADMS (Adaptive Density Minimal Surface)"}),"\n",(0,t.jsx)(n.p,{children:"ADMS is a unique geometry approach employed by spherene, representing a novel class of minimal surfaces. It enables the generation of structures with localized adjustments to density and thickness while retaining the properties of a minimal surface (zero mean curvature). This geometry adapts to the surrounding geometry and provides two independent chambers (labyrinths) without enclosed spaces, making it suitable for all 3D printing methods. The key advantages of ADMS include easy powder/resin evacuation, support-free 3D printing, high stiffness with little material use, reduced energy consumption, and a lower carbon footprint."}),"\n",(0,t.jsx)(n.h2,{id:"spherene--spherenes",children:"spherene / spherenes"}),"\n",(0,t.jsx)(n.p,{children:"spherene is the metamaterial structure computed using the ADMS technology."}),"\n",(0,t.jsx)(n.p,{children:"There is an infinite amount of spherenes, each spherene that you create is unique."}),"\n",(0,t.jsx)(n.h2,{id:"envelope-env",children:"Envelope (env)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The primary input geometry from which spherene is generated."}),"\n",(0,t.jsx)(n.li,{children:"Describes the outermost surface of the geometry."}),"\n",(0,t.jsxs)(n.li,{children:["Only one ",(0,t.jsx)(n.code,{children:"env"})," can exist per project."]}),"\n",(0,t.jsx)(n.li,{children:"Is a triangulated solid used for trimming the raw ADMS."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"defeatured-envelope-dfenv",children:"Defeatured Envelope (dfenv)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A simplified shape completely encompassing ",(0,t.jsx)(n.code,{children:"env"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Utilized to grow ADMS further outside of the ",(0,t.jsx)(n.code,{children:"env"})," to vary the target connection angle from being perpendicular to arbitrary, resulting in different looks."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"boundary-boundary",children:"Boundary (boundary)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"One or multiple meshes used as a triangulated surface or a triangulated solid."}),"\n",(0,t.jsxs)(n.li,{children:["Ideally follows ",(0,t.jsx)(n.code,{children:"env"})," surface or is part of a trimmed ",(0,t.jsx)(n.code,{children:"env"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Can be positioned freely and grows and thickens ADMS towards that surface, applying a wall thickness and a blend distance. Labyrinths can be selectively be closed."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"field-points",children:"Field Points"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A function calculated at a particular point in space, with different types such as density field, thickness field, cavity and surface bias field."}),"\n",(0,t.jsx)(n.li,{children:"If only one field point for density, thickness, cavity or surface bias is set, is will be evaluated as a constant field."}),"\n",(0,t.jsx)(n.li,{children:"More field points will be interpolated between the point locations."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"density-field-points",children:"Density Field Points"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Set the density at the point location."}),"\n",(0,t.jsx)(n.li,{children:"The higher the Density Reference Thickness (DRT), the less complex the result."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"thickness-field-points",children:"Thickness Field Points"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Set the wall thickness at the point location."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"surface-bias-field-points",children:"Surface Bias Field Points"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Allow the shifting of the Single Surface to the negative or positive of its normal."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"cavity-points",children:"Cavity Points"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Add a cavity at the point location with a specified radius."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"density-reference-thickness-drt",children:"Density Reference Thickness (DRT)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Defines the wall thickness if no Thickness Field is present."}),"\n",(0,t.jsx)(n.li,{children:"If no Thickness Field is present and the Density Field has only one point, the volume fraction of the solid corresponds to the density value stated in the Density Field point."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"computing-spherene",children:"Computing spherene"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The process of generating spherene based on the defined parameters and geometry, resulting in two kinds of surfaces: Single Surface (si) and Solid Surface (SO)."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"single-surface",children:"Single Surface"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Minimal surface / 2D ADMS."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"solid-surface",children:"Solid Surface"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A solid derived from a surface, appears (almost) identical to the surface, but has added wall width."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);